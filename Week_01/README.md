# 数组、链表、跳表

## 数组
时间复杂度
- prepend: O(1)，正常情况是O(1)的，可以在数组最开始预留一部分空间
- append: O(1)
- lookup: O(1)
- insert: O(n)
- delete: O(n)

## 链表
时间复杂度
- prepend: O(1)
- append: O(1)
- lookup: O(n)
- insert: O(1)
- delete: O(1)

## 跳表
### 原理及实现
**只能用于元素有序的情况**
可以看作是针对有序链表查询时间复杂度为O(n)的一种优化，即空间换时间

跳表（skip list）对标的是平衡树（AVL Tree）和二分查找，是一种 插入/删除/搜索 都是**O(log n)**的数据结构

最大的优势是原理简单、容易实现、方便扩展、效率更高

给有序链表加速，可添加多级索引

空间复杂度是O(n)

升维思想 + 空间换时间

## 工程运用

- LRU Cache - Linked list
- Redis - Skip List

## 栈、队列、双端队列、优先队列

## Stack

Stack，先进后出（FILO，First In Last Out）
- 增加、删除皆为O(1)操作
- 查找为O(n)操作

## Queue
  
Queue，先进先出（FIFO，First In Last Out）
- 增加、删除皆为O(1)操作
- 查找为O(n)操作

## Deque
  
Deque，两端都可以进出的Queue（Deque - double end queue）
- 插入和删除都是O(1)操作
- 查找为O(n)操作

## Priority Queue
Priority Queue，优先队列
 - 插入操作：O(1)
 - 取出操作：O(log n) - 按照元素的优先级顺序取出
 - 底层具体实现的数据结构较多样和复杂：heap、bst、treap



# 解题总结
## 解题步骤
1. 5-10分钟：读题和思考
2. 有思路：自己开始做和写代码；不然，马上看题解
3. 默写背诵、熟练
4. 然后开始自己写（闭卷）


## 思路总结：
> 解题的最大思想以及最大的误区，最大误区做题只做一遍（至少5遍），最大思想（优化思想）是空间换时间、升维（升到二维去）；

1. 解题在懵逼的时候要怎么办？
- 面对算法题目先不要看这么复杂，先思考一些最基本的情况：
    
- 首先能不能暴力？
- 其次最基本的情况是咋样？看看能不能化繁为简的思考.

2. 关键法：找最近重复的子问题
- 为什么要找最近重复的子问题？ 因为我们写程序只能写 `if else for while recursion`
        
- `for while recursion` 的话都是不断的重复，究其原因计算机是人类发明的，人类发明出来的工具肯定没有人脑这么强（未来不一定～）它其实就是一个简单重复式的机器，再加上我们现在用的这些程序和这些算法都是最基本的，所以不涉及任何关于人工智能的东西，你就把它想成不断重复在那做事情的一个东西，你要让它用重复的东西来解决问题你这种问题说明什么，说明这个问题本身就是可重复的。