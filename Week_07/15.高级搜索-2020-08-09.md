# 15.高级搜索
- 剪枝
- 双向BFS
- 启发式搜索（A*）

## 1. 剪枝的实现和特性

### **初级搜索**

所谓的初级搜索的话就是傻搜或者暴力搜索，它主要可以优化的方向，或者是怎么把它变高级，主要是这两个领域：
- 第一个领域就是不重复和所谓的剪枝，这两者是相辅相成的。
- 第二个是它的搜索方向上还可以进行优化，一种是双向搜索，二是启发式搜索（A*）

1. 朴素搜索
2. 优化方式：不重复（fibonacci）、剪枝（生成括号问题）
3. 搜索方向： \
   DFS : depth first search 深度优先搜索 \
   BFS : breadth first search 广度优先搜索 \
   双向搜索、启发式搜索
   
> 不重复大家可以想就是第一`Fibonacci`问题，`Fibonacci` 问题大家可以想一下那个状态树是什么，如果你只是简单写一个递归程序，没有进行任何判重的话，那么它有大量的重复的结点的计算，那么时间复杂度沦为指数级的，可以用的办法，就是用所谓的数组来存它的中间值，或者是可以直接用顺推的办法避免重复中间重复状态，这就是把它的重复性给去掉。

> 另外的话还有其他的更加高级的剪枝，例如：生成括号问题，你也可以认为在处理 `Fibonacci` 问题上，我们也进行来所谓的剪枝，这都是异曲同工的，所谓的剪枝就是整个状态树，这一个分支是没有必要的时候，那么我们就把它剪掉不进行搜索，这种没有必要性是来自一个是重复，当然也有可能是每次要找的分支是次优或者不够优的，不是所谓的最优解，那就把它剪掉。

> 那么另外一个优化的方向就是在它的搜索方向上还可以进行优化。它的搜索方向的主要是深度优先搜索和广度优先搜索两个方向，在这里你会发现它所谓的深度优先和广度优先，只是因为计算机数据结构里面有个所谓的：先入后出的栈和先入先出的队列导致来整个搜的时候是这两方面，但是你细想的话就是说广度优先可能还好一点，广度优先一般扩散到的都是距离最近的，但是深度优先的话其实就是傻搜索或者就是一路不回头，直到撞到南墙才回头继续，那么它这种的话并没有所谓的按照优先级或者没有任何的智能性。

> 那么在这里优化搜索的高级两种：一种是双向搜索（双向搜索级可以理解为它从起点和终点分别做一个广度优先，然后在中间相遇，这样时间会更快），另外一个就是启发式搜索（启发式搜索就不再是用栈或者用队列这种先入先出、先入后出的形式，而是用一个优先队列放在里面，优先队列是按照它的优先级，也就是有些结点可能会达到我们需要的结果的话，就先把它从队列里面拿出来进行搜索，这个就叫做启发式搜索，也叫做$A^*$算法或者叫做优先级搜索）

关于[《深度优先搜索和广度优先搜索》](https://juejin.im/post/6850418113256062989)你可以去看一下我之前写的一篇文章。

### **剪枝**

![](https://imgkr2.cn-bj.ufileos.com/02c582c9-1baf-4e27-a5f8-1f15b00c7e52.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=JmzdLIW4iIZFwONvXIUxW2X%252FtuU%253D&Expires=1596980834)

所谓剪枝就是涉及到状态树，在状态树进行搜索的时候，如果发现这个分支已经处理国内的，那么我们就把它暂存在缓存里面，整个分支的话就可以剪掉，不需要再手动进行计算，当然有些时候是分支不够好，所谓的叫做较差的分支或者是次优的分支，我们也可以把它剪掉。这就是剪枝，之所以有这种枝条的形态，就是因为整个状态树的话是一种所谓的树和枝叶的形态。例如：零钱置换的状态树。

![](https://imgkr2.cn-bj.ufileos.com/ee79dbcb-74d4-4069-a280-2479a375d2bd.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=KUzOeIWGlJDW4CVp%252F0YS0IPuQXM%253D&Expires=1596981025)

那么在这里很多人就可能会问了，那么计算机速度这么快的话，那些问题状态空间还需要剪呢？
这里想讲第一`Fibonacci`问题，它其实状态空间就比较繁复了，另外的话就是很不幸在人类生活世界当中具体问题，它的状态树的空间大小一般来说都是比较恐怖的。这里来看几个案例：

**国际象棋**

当年的话这一仗是人类选手**卡斯帕罗夫** 和计算机深蓝进行的一场对决，这个对决的话在90年代初那时候名噪一时，当时的话就是用普通的笔记本，用最基本的搜索再加剪枝和一些优化的算法，最后的话战胜了卡斯帕罗夫，当然是险胜。
![](https://imgkr2.cn-bj.ufileos.com/01cacdea-d68d-41da-99f6-d444c87be6ec.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=9E9m94xaoHzxi6vA5HtHi3DTkNc%253D&Expires=1596981773)

这个棋本身的话就是用的最朴素的搜索办法，本身的话它最后赢的棋谱，这一仗是1996年在费城2月10号深蓝对阵卡斯帕罗夫。下图最下面棋谱1指的是每个人走了一步，第2每个人走了两步，最后的话你会发现是每个人走了37步之后决出了胜局。所谓的走37步就是这个状态树，它的深度是37，所以你可以看到就算它每一层深度的分叉两个分叉罢了，那就是2的37次方也是非常大的，当然这里不止两个分叉，所以你可以看到这里状态树空间非常大，正是因为深蓝在这里进行了大量的剪枝。
![](https://imgkr2.cn-bj.ufileos.com/4469a9c0-635f-4e31-a9aa-fd79b3bc7ee2.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=w9W0Az4y%252BrH%252BFs6I0LSuOko5rRM%253D&Expires=1596981711)

它每一层的分支的接近于10的，正是因为这样的话，它的程序就是异常复杂，到了90年代那个时候的话随着计算机本身的发展，以及后来剪枝用得越来越好了，那么后来慢慢就攻克了这个棋。
![](https://imgkr2.cn-bj.ufileos.com/b694ecd4-e514-4fb4-b09f-8491c20c4785.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=ImrtLaB%252BmEOL6eh%252BF0MttWiE5ec%253D&Expires=1596983410)


**三子棋、五子棋等**

三子棋，我想大家上课的时候或者课间的时候都玩过，就画一个`3*3`的棋盘两个人玩，一个人走`O`一个人走`X`，最后看谁连在一起的，可以是竖的，可以是横的。

![](https://imgkr2.cn-bj.ufileos.com/c8f91b64-7577-4d5f-b2d6-0bb945baca4d.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=%252FNMcyNXdhreGi0eSjCliA4Qh07U%253D&Expires=1596982454)

依照这样子的话就可以走出来，它这样一个状态树了，走出来这个状态树你会发现当 `X` 走在这个地方（红色圈），那么最后结局已经注定了，肯定 `X` 已经赢了，唯一一种kennel就是走到这个分支的话（绿色圈）最后走到这边是平局。所以当它走到这两步的时候（橙色矩形）已经判断至少 `X`  是不败的了。也就是说你把整个状态树都之前已经遍历过一次的话，这时候你基本上属于一种开天眼的状态，也就是不败的状态，所以关键就在于这个状态树的深度，你能不能搞定以及有没有什么很好的办法去剪枝，三子棋因为状态空间相对简单，所以你随便怎么写程序都可以搞定，也就是在最开始计算机搜索出来的时候，三子棋基本上就是必胜了对人类。

![](https://imgkr2.cn-bj.ufileos.com/8b29509f-141d-406d-b993-efe91b2b8459.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=%252BrF5igqxHKbkmdZchmSkbTPcmR4%253D&Expires=1596983111)

**围棋**
围棋在这里最后走的步数是276步，而且棋盘异常的大，所以的话它的状态空间的话，比国际象棋其实要大不少的。
![](https://imgkr2.cn-bj.ufileos.com/a0ee9a1b-6acd-4704-9177-873a3daa2d94.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=rrOjOLx7LlfHtLlAl1GpNM4rxs4%253D&Expires=1596983775)

它这里还有一个复杂度的来源就是在于它每一层的分支的个数也非常的多。原因就是说你每次在国际象棋上面你动的步数是有限的，但是围棋可就不一样了，只要有空地都可以落上去，当然有一些特别傻的位置就直接剪枝剪掉了，但是它可以落子的位置的话，其实是没有任何明显的限制的，而且可以落子的选择性非常多。

这里它的状态树是来自于 `AlphaGo` 的文章，它的状态树是异常复杂的，以至于开始用朴素的剪掉这种搜索无法有效地处理它所谓的状态树，找到最优的情况，第一它cover不l这么深的深度，另外的话分支太多了之后，直接又把它搜索空间给撑爆了，因为这个原因的话，直到最近的几年才是由于深度学习的一种方法，把它最后解决了，用深度学习的办法也是同样的思路，在这个状态树里面进行更加有效地评估，哪个分支更好以及更加及时地给剪枝出去，所以你会发现虽然用了深度学习，但是它整个思想和之前是异曲同工的。
![](https://imgkr2.cn-bj.ufileos.com/f3e5cbc0-68c9-475f-acb1-31db9e9de0d2.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=Go6Sgx67zuDkJdw1mx498%252FTUzMc%253D&Expires=1596984149)

在这里给大家介绍一个科普的文章 AlphaGo这块：[AlphaZero Explained](https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/)
> AlphaZer 也是Goole出的一个改进版的人工智能程序。

**Wiki棋类复杂度**

[棋类复杂度](https://en.wikipedia.org/wiki/Game_complexity)
![](https://imgkr2.cn-bj.ufileos.com/831bb42c-d69c-4f01-b9b1-7df7302e4c45.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=oqpDIYfyqgaysSIavkulCsL7ATs%253D&Expires=1596984680)

### 回溯法
回溯法采用试错的思想，它尝试分布的去解决一个问题。在分布解决问题的过程中，当它通过尝试发现现有的分布答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分布解答再次尝试寻找问题的答案。

回溯法通常用最剪掉的递归方法来实现，在反复重复上述的步骤后kennel出现两种情况：
- 找到一个可能存在的正确的答案。
- 在尝试来所有可能的分布方法后宣告该问题没有答案。

在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。











![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe0e9ba5e718490ea49950590dda1491~tplv-k3u1fbpfcp-zoom-1.image)



    部分图片来源于网络，版权归原作者，侵删。

    👇点击阅读原文，查看往期内容！

                          快留言👇和我互动吧～